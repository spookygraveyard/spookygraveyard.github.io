<!DOCTYPE html>

<html lang="en-us">

<head>
	<meta charset="utf-8">
	<style>
		body{
		background-color: #222222;
		}
		
		td{
		border: 1px solid #333333;
		}
		
		button{
		height:26px;
		}
		
		.maingrid { 
		display: grid; 
		grid-gap: 5px; 
		grid-template-columns: 200px 100px 100px 350px; 
		grid-template-rows: 30px 30px 200px 30px 30px 200px 30px;
		margin-left:auto;
		margin-right:auto;
		width:750px;
		}
		
		.displayButton {
		width: 60px;
		}
		
		#fileNameGrid { 
		grid-row: 1; 
		grid-column: 1 / 4; 
		border-style: solid; 
		border-width: 1px;
		font-size: 24px;
		padding-left: 5px;
		background-color: #111111;
		color: white;
		border-color: #BBBBBB;
		}
		
		#loadButtonsGrid { 
		grid-row: 1; 
		grid-column: 4; 
		border-style: solid; 
		border-width: 1px;
		background-color: #111111;
		border-color: #BBBBBB;
		padding-top:1px;
		}
		
		#lineButtonsGrid { 
		grid-row: 2; 
		grid-column: 1; 
		border-style: solid; 
		border-width: 1px;
		text-align: center;
		padding-top:1px;
		background-color: #111111;
		border-color: #BBBBBB;
		}
		
		#twoDViewGrid { 
		    grid-row: 2 / 4; 
		    grid-column: 2 / 4; 
		    border-style: solid; 
		    border-width: 1px; 
		    background-color: black;
		}

        #reportsTitleGrid {
            grid-row: 2;
            grid-column: 4;
            border-style: solid;
            border-width: 1px;
            border-color: #BBBBBB;
            background-color: #111111;
            text-align: center;
            font-size: 18px;
            padding-top: 3px;
            color: white;
        }

        #2dViewSVG {
            width: 200px;
            height: 230px;
        }

        #lineChartGrid {
            grid-row: 3 / 8;
            grid-column: 1;
            background-color: #111111;
        }
		
		#reportsGrid { 
		grid-row: 3 / 5; 
		grid-column: 4; 
		border-style: solid; 
		border-width: 1px;
		background-color: #111111;
		border-color: #BBBBBB;
		color: white;
		overflow-y:scroll;
		font-family: monospace;
		font-size:14px;
		}
		
		#measureButtonsGrid { 
		grid-row: 4; 
		grid-column: 2 / 4; 
		border-style: solid; 
		border-width: 1px;
		background-color: #111111;
		border-color: #BBBBBB;
		text-align: center;
		padding-top:1px;
		}
		
		#measureResultsGrid { 
		grid-row: 5; 
		grid-column: 2 / 4; 
		border-style: solid; 
		border-width: 1px;
		text-align: center;
		padding-top: 3px;
		font-size: 18px;
		background-color: #111111;
		border-color: #BBBBBB;
		color: white;
		}
		
		#ySubLineGrid { 
		grid-row: 6 / 8; 
		grid-column: 2; 
		border-style: solid; 
		border-width: 1px; 
		background-color: black;}
		
		#xSubLineGrid { 
		grid-row: 6 / 8; 
		grid-column: 3; 
		border-style: solid; 
		border-width: 1px; 
		background-color: black;
		}
		
		#saveButtons { 
		grid-row: 5; 
		grid-column: 4; 
		border-style: solid; 
		border-width: 1px; 
		background-color:#111111;
		border-color: #BBBBBB;
		padding-top:1px;
		}
		
		#dataControls {
		grid-row: 6 / 8;
		grid-column: 4;
		border-style: solid; 
		border-width: 1px; 
		background-color:#111111;
		border-color: #BBBBBB;
		color: white;
		padding: 5px;
        font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
		}
		
		#measureButton {
		width: 70px;
		}
		
		#clearMeasureButton {
		width: 65px;
		}
		
		#ampTableHeader {
		width:55px;
		}
		
		#rotationTextBox {
		width: 45px;
		}
	</style>
	
</head>

<body>
	<script src="js/three.min.js"></script>
	<script src="js/webgl.js"></script>
	<script src="js/stats.min.js"></script>
	<div class="maingrid">
		<div id="fileNameGrid" >
			<em>DHR003C045I043</em>
		</div>

        <div id="loadButtonsGrid">
            <input type="file" id="input" />
            <button>Cloud Data</button>
        </div>

		<div id="lineButtonsGrid">
			<button oncontextmenu="javascript: changeChan(-1); return false;" onclick="changeChan(1)" title="Channel" id="channelButton" class="displayButton">1</button>
			<button title="Frequency" class="displayButton">450</button>
			<button title="Direction" class="displayButton">Vert</button>
		</div>

		<div id="twoDViewGrid">
            <svg id="2dViewSVG" width="100%" height="100%" viewBox="0 0 200 230" preserveAspectRatio="none">
                <line x1="0" x2="200" y1="115" y2="115"
                      style="fill:none;stroke:#333333;stroke-width:1;stroke-dasharray:3">
                </line>
                <line x1="100" x2="100" y1="0" y2="230"
                      style="fill:none;stroke:#333333;stroke-width:1;stroke-dasharray:3">
                </line>
                <line x1="0" x2="200" y1="15" y2="215"
                      style="fill:none;stroke:#333333;stroke-width:1;stroke-dasharray:3">
                </line>
                <line x1="0" x2="200" y1="215" y2="15"
                      style="fill:none;stroke:#333333;stroke-width:1;stroke-dasharray:3">
                </line>
                <circle r="20" cx="100" cy="115"
                        style="fill:none;stroke:#333333;stroke-width:1;stroke-dasharray:3">
                </circle>
                <circle r="40" cx="100" cy="115"
                        style="fill:none;stroke:#333333;stroke-width:1;stroke-dasharray:3">
                </circle>
                <circle r="60" cx="100" cy="115"
                        style="fill:none;stroke:#333333;stroke-width:1;stroke-dasharray:3">
                </circle>
                <circle r="80" cx="100" cy="115"
                        style="fill:none;stroke:#333333;stroke-width:1;stroke-dasharray:3">
                </circle>
                <circle r="100" cx="100" cy="115"
                        style="fill:none;stroke:#333333;stroke-width:1;stroke-dasharray:3">
                </circle>
                <polyline points="0 0"
                          style="fill:none;stroke:white;stroke-width:2"
                          id="liss">
                </polyline>
                <circle r="3" cx="-10" cy="-10"
                        style="fill:none;stroke:red;stroke-width:1;"
                        id="2dCenterCircle">
                </circle>

            </svg>
		</div>

		<div id="reportsTitleGrid">
			Reported Measurements
		</div>

        <div id="lineChartGrid" onmousemove="changeIndex(event)"></div>
		
        <div id="reportsGrid">
			<table>
			    <thead>
                    <tr>
                        <th>Type</th>
                        <th id="ampTableHeader">Amp</th>
                        <th>Phase</th>
                        <th>Call</th>
                    </tr>
                </thead>
                <tbody id="reportTable">
                    <tr><td>Vpp</td><td>2.14</td><td>145</td><td>ID Groove</td></tr>
                </tbody>
			</table>
		</div>

		<div id="measureButtonsGrid" >
			<select id="measurementSelection">
			    <option>Vpp</option>
			    <option>Vmx</option>
			    <option>Hmx</option>
			    <option>MxR</option>
			</select>
			<button id="measureButton">Measure</button>
			<button onclick="addNewReport()" id="clearMeasureButton">Report</button>
		</div>

		<div id="measureResultsGrid" >
			3.14 volts 345 deg
		</div>

		<div id="ySubLineGrid" mousedown="setInitalY(event)" onmousemove="changeSubSelection(event)" oncontextmenu="javascript: return false;">
            <svg id="subLineYSVG" width="100%" height="100%" viewBox="0 0 100 230" preserveAspectRatio="none">
                <polyline points="0 0"
                          style="fill:none;stroke:white;stroke-width:2"
                          id="subLineY">
                </polyline>
                <line id="ysubtop" x1="0" x2="100" y1="30" y2="30" style="stroke:rgb(255,0,0);stroke-width:1;stroke-dasharray:2;"></line>
                <line x1="0" x2="100" y1="115" y2="115" style="stroke:rgb(255,0,0);stroke-width:1"></line>
                <line id="ysubbot" x1="0" x2="100" y1="200" y2="200" style="stroke:rgb(255,0,0);stroke-width:1;stroke-dasharray:2"></line>
            </svg>
		</div>

		<div id="xSubLineGrid" mousedown="setInitalY(event)" onmousemove="changeSubSelection(event)" oncontextmenu="javascript: return false;">
            <svg id="subLineXSVG" width="100%" height="100%" viewBox="0 0 100 230" preserveAspectRatio="none">
                <polyline points="0 0"
                          style="fill:none;stroke:white;stroke-width:2"
                          id="subLineX">
                </polyline>
                <line id="xsubtop" x1="0" x2="100" y1="30" y2="30" style="stroke:rgb(255,0,0);stroke-width:1;stroke-dasharray:2;"></line>
                <line x1="0" x2="100" y1="115" y2="115" style="stroke:rgb(255,0,0);stroke-width:1"></line>
                <line id="xsubbot" x1="0" x2="100" y1="200" y2="200" style="stroke:rgb(255,0,0);stroke-width:1;stroke-dasharray:2"></line>
            </svg>
		</div>
		<div id="saveButtons">
			<button>Save Local Report</button>
			<button>Save Report Cloud</button>
		</div>
        <div id="dataControls">
            <div id="fileSizeText">-</div>
            <div id="pointCountText">-</div>
            <div id="xPos">-</div>
            <div id="yPos">-</div>
            <div id="indexVal">-</div><br />
            <button onclick="setScale(2)">Viewscale x2</button>
            <button onclick="setScale(0.5)">Viewscale /2</button>
            <div id="subWindowText">-</div>
        </div>
	</div>
	
	<script>
		if ( WEBGL.isWebGLAvailable() === false ) {
			document.body.appendChild( WEBGL.getWebGLErrorMessage() );
		}
		var container, stats;
		var camera, scene, renderer;
        var mesh;
        var rawPoints;
        var channel = 0;
        var firstRender = true;
        var index = 0;
        var subMax = 121;
        var scaleFactor = 0.1;
        var subCurrent = 161;
        var initialY = -1;

        document.addEventListener('keypress', (event) => {
            const keyName = event.key;
            if (keyName == "s")
                keyChangeIndex(-1);
            else if (keyName == "w")
                keyChangeIndex(1);
            else if (keyName == "a")
                changeChan(-1);
            else if (keyName == "d")
                changeChan(1);
        });

        function setInitalY(ev) {
            var rect = document.getElementById('ySubLineGrid').getBoundingClientRect();
            initialY = ev.clientY - rect.top;
        }

        function changeSubSelection(ev) {
            if (ev.buttons === 2) {
                if (rawPoints == null || rawPoints.length < 4)
                    return;
                var rect = document.getElementById('ySubLineGrid').getBoundingClientRect();
                var y = ev.clientY - rect.top;
                var almost = Math.abs(y - 230 / 2);
                subCurrent = Math.round(almost * subMax / 230 * 2);
                if (subCurrent > subMax)
                    subCurrent = subMax;
                if (subCurrent < 3)
                    subCurrent = 3;
                var delta = Math.round((subMax - subCurrent) / 2 * 230 / subMax);
                updateSelectionLinePos(230, delta);
                update2DPoints(false, scaleFactor);
                document.getElementById('subWindowText').innerHTML = "sub window:" + subCurrent;
            }
            else if (ev.buttons === 1) {
                var rect = document.getElementById('ySubLineGrid').getBoundingClientRect();
                var newY = ev.clientY - rect.top;
                if (newY > initialY)
                    keyChangeIndex(1);
                else if (newY < initialY)
                    keyChangeIndex(-1);
                initialY = newY;
            }
        }

        function updateSelectionLinePos(top, delta) {
            document.getElementById('xsubtop').setAttribute('y1', top - delta);
            document.getElementById('xsubtop').setAttribute('y2', top - delta);
            document.getElementById('xsubbot').setAttribute('y1', delta);
            document.getElementById('xsubbot').setAttribute('y2', delta);

            document.getElementById('ysubtop').setAttribute('y1', top - delta);
            document.getElementById('ysubtop').setAttribute('y2', top - delta);
            document.getElementById('ysubbot').setAttribute('y1', delta);
            document.getElementById('ysubbot').setAttribute('y2', delta);
        }

        function addNewReport() {
            switch (measurementSelection.selectedIndex) {
                case 0: vpp(); break;
                case 1: vmx(); break;
                case 2: hmx(); break;
                case 3: mxr(); break;
            }

            var tBody = document.getElementById("reportTable");
            var newRow = tBody.insertRow(tBody.rows.length);
            var newCell = newRow.insertCell(0);
            var newText = document.createTextNode('Vpp');
            newCell.appendChild(newText);
            newCell = newRow.insertCell(1);
            newText = document.createTextNode('1.15');
            newCell.appendChild(newText);
            newCell = newRow.insertCell(2);
            newText = document.createTextNode('255');
            newCell.appendChild(newText);
            newCell = newRow.insertCell(3);
            newText = document.createTextNode('Test');
            newCell.appendChild(newText);
        }

        function vpp() {
            var amp = 1.1;
            var phase = 255;
            var subStart = Math.round(subMax / 2 - subCurrent / 2);
            var subEnd = Math.round(subMax / 2 + subCurrent / 2);
            var maxDist = -1;
            var bigIndex1 = -1;
            var bigIndex2 = -1;
            // Yeah, it's a brute force algo, what about it?
            for (var i = subStart; i < subEnd; i++) {
                for (var j = subStart + 1; j < subEnd; j++) {
                    pointDistance((i + index - subMax / 2) * 16 + channel, (j + index - subMax / 2) * 16 + channel);
                }
            }
            document.getElementById("measureResultsGrid").innerHTML = amp + " volts " + phase + " deg";
        }

        function pointDistance(index1, index2) {

        }

        function vmx() {
            document.getElementById("measureResultsGrid").innerHTML = "vmx";
        }

        function hmx() {
            document.getElementById("measureResultsGrid").innerHTML = "hmx";
        }

        function mxr() {
            document.getElementById("measureResultsGrid").innerHTML = "MMXXRR";
        }

        function setScale(valIn) {
            scaleFactor *= valIn;
            update2DPoints(true, scaleFactor);
            camera.left /= valIn;
            camera.right /= valIn;
            camera.updateProjectionMatrix();
        }

        function update2DPoints(updateSubLines, scale) {
            var svg = document.getElementById('2dViewSVG');
            var rect = svg.getBoundingClientRect();
            var polyline = document.getElementById('liss');
            polyline.setAttribute("points", "");
            var xStart = rawPoints[(index - subMax / 2) * 16 + channel];
            var yStart = rawPoints[(index - subMax / 2) * 16 + channel + 1];
            var subStart = Math.round(subMax / 2 - subCurrent / 2);
            var subEnd = Math.round(subMax / 2 + subCurrent / 2);
            for (var i = subStart; i < subEnd; i++) {
                var point = svg.createSVGPoint();
                point.x = (rawPoints[(i + index - subMax / 2) * 16 + channel] - xStart) * scale + rect.width / 2;
                point.y = (rawPoints[(i + index - subMax / 2) * 16 + channel + 1] - yStart) * scale + rect.height / 2;
                polyline.points.appendItem(point);
                if (i === Math.round(subMax / 2)) {
                    document.getElementById('2dCenterCircle').setAttribute("cx", point.x);
                    document.getElementById('2dCenterCircle').setAttribute("cy", point.y);
                }
            }

            if (updateSubLines) {
                updateXLine(scale);
                updateYLine(scale);
            }
        }

        function updateXLine(scale) {
            var svg = document.getElementById('subLineXSVG');
            var rect = svg.getBoundingClientRect();
            var polyline = document.getElementById('subLineX');
            polyline.setAttribute("points", "");
            var xStart = rawPoints[(index - subMax / 2) * 16 + channel]
            var yPos = 230;
            var step = 230 / subMax;
            for (var i = 0; i < subMax; i++) {
                var point = svg.createSVGPoint();
                point.x = (rawPoints[(i + index - subMax / 2) * 16 + channel] - xStart) * scale + rect.width / 2;
                point.y = yPos;
                polyline.points.appendItem(point);
                yPos -= step;
            }
        }

        // lots of optimization possible
        function updateYLine(scale) {
            var svg = document.getElementById('subLineYSVG');
            var rect = svg.getBoundingClientRect();
            var polyline = document.getElementById('subLineY');
            polyline.setAttribute("points", "");
            var xStart = rawPoints[(index - subMax / 2) * 16 + channel + 1]
            var yPos = 230;
            var step = 230 / subMax;
            for (var i = 0; i < subMax; i++) {
                var point = svg.createSVGPoint();
                point.x = (rawPoints[(i + index - subMax / 2) * 16 + channel + 1] - xStart) * scale + rect.width / 2;
                point.y = yPos;
                polyline.points.appendItem(point);
                yPos -= step;
            }
        }

        function changeChan(valIn) {
            if (rawPoints == null || rawPoints.length < 10)
                return;
            channel += valIn;
            if (channel > 7)
                channel = 0;
            else if (channel < 0)
                channel = 7;

            setPoints(rawPoints, channel);
            document.getElementById('channelButton').innerText = channel + 1;
            update2DPoints(true, scaleFactor);
        }

        function keyChangeIndex(valIn) {
            index += valIn;
            document.getElementById('indexVal').innerHTML = "index: " + index;
            update2DPoints(true, scaleFactor);
        }

        function changeIndex(ev) {
            if (rawPoints == null || rawPoints.length < 4)
                return;
            var rect = ev.target.getBoundingClientRect();
            var x = ev.clientX - rect.left; //x position within the element.
            var y = ev.clientY - rect.top;  //y position within the element.

            if (ev.buttons === 1) {
                document.getElementById('xPos').innerHTML = "x: " + x;
                document.getElementById('yPos').innerHTML = "y: " + y;
                index = (rawPoints.length / 16) - Math.round(y * ((rawPoints.length / 16) / rect.height));
                document.getElementById('indexVal').innerHTML = "index: " + index;

                update2DPoints(true, scaleFactor);
            }
        }

		function setPoints(points, chan) {
			container = document.getElementById( 'lineChartGrid' );
			var width = 200;
            var height = 510;
            if (firstRender) {
                camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 0.1, 10000);
                camera.position.z = 2750;
            }
            else {
                scene.remove(0);
            }
            scene = new THREE.Scene();
            var segments = points.length / 16;
			var geometry = new THREE.BufferGeometry();
			var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
			var positions = [];
			var colors = [];
			var step = height / segments;
			var zPos = -height / 2;
			var viewScale = 50;
            for (var i = 0; i < segments -1; i++) {
                var x = points[i * 16 + chan] / viewScale;
				var y = zPos;
                var z = points[i * 16 + 1 + chan] / viewScale;
				zPos += step;
				// positions
				positions.push( x, y, z );
				// colors
				colors.push((zPos + height / 2) / height);
				colors.push(0.1);
				colors.push(1 - (zPos + height / 2) / height);
			}
			geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
			geometry.computeBoundingSphere();
			mesh = new THREE.Line( geometry, material );
			scene.add( mesh );

            if (firstRender) {
			    renderer = new THREE.WebGLRenderer();
			    renderer.setPixelRatio( window.devicePixelRatio );
			    renderer.setSize( width, height );
			    renderer.gammaInput = true;
                renderer.gammaOutput = true;

                container.appendChild(renderer.domElement);

                stats = new Stats();
                container.appendChild(stats.dom);

                animate();
            }
            firstRender = false;
		}

        var inputElement = document.getElementById("input");
        inputElement.addEventListener("change", handleFiles, false);

        function handleFiles() {
            var fileList = this.files;
            var mainFile = fileList[0];
            document.getElementById('fileSizeText').innerHTML = mainFile.size + " bytes";
            var reader = new FileReader();               
            reader.readAsText(mainFile);
            reader.onloadend = function () {
                var csv = reader.result;
                rawPoints = csv.split(",");
                rawPoints = rawPoints.slice(0, -1);
                document.getElementById('pointCountText').innerHTML = rawPoints.length + " points";
                index = rawPoints.length / 32;
                setPoints(rawPoints, 0);
            }
        }

		function animate() {
			requestAnimationFrame( animate );
			render();
			stats.update();
		}
		function render() {
			var time = Date.now() * 0.001;
			//mesh.rotation.z = time * 0.25;
			mesh.rotation.y = time * 0.5;
			renderer.render( scene, camera );
		}
	</script>

</body>

</html>
